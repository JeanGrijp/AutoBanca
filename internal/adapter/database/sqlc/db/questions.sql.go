// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: questions.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countQuestions = `-- name: CountQuestions :one
SELECT COUNT(*) FROM questions
`

func (q *Queries) CountQuestions(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countQuestions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countQuestionsByAno = `-- name: CountQuestionsByAno :one
SELECT COUNT(*) FROM questions WHERE ano = $1
`

func (q *Queries) CountQuestionsByAno(ctx context.Context, ano int32) (int64, error) {
	row := q.db.QueryRow(ctx, countQuestionsByAno, ano)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countQuestionsByAnoAndNivel = `-- name: CountQuestionsByAnoAndNivel :one
SELECT COUNT(*) FROM questions WHERE ano = $1 AND nivel = $2
`

type CountQuestionsByAnoAndNivelParams struct {
	Ano   int32       `json:"ano"`
	Nivel pgtype.Text `json:"nivel"`
}

func (q *Queries) CountQuestionsByAnoAndNivel(ctx context.Context, arg CountQuestionsByAnoAndNivelParams) (int64, error) {
	row := q.db.QueryRow(ctx, countQuestionsByAnoAndNivel, arg.Ano, arg.Nivel)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countQuestionsByAreaAtuacao = `-- name: CountQuestionsByAreaAtuacao :one
SELECT COUNT(*) FROM questions WHERE area_atuacao = $1
`

func (q *Queries) CountQuestionsByAreaAtuacao(ctx context.Context, areaAtuacao pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, countQuestionsByAreaAtuacao, areaAtuacao)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countQuestionsByAreaFormacao = `-- name: CountQuestionsByAreaFormacao :one
SELECT COUNT(*) FROM questions WHERE area_formacao = $1
`

func (q *Queries) CountQuestionsByAreaFormacao(ctx context.Context, areaFormacao pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, countQuestionsByAreaFormacao, areaFormacao)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countQuestionsByAssunto = `-- name: CountQuestionsByAssunto :one
SELECT COUNT(*) FROM questions WHERE assunto_id = $1
`

func (q *Queries) CountQuestionsByAssunto(ctx context.Context, assuntoID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countQuestionsByAssunto, assuntoID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countQuestionsByDificuldadeAndInstituicao = `-- name: CountQuestionsByDificuldadeAndInstituicao :one
SELECT COUNT(*)
FROM questions
WHERE
    dificuldade = $1
    AND instituicao = $2
`

type CountQuestionsByDificuldadeAndInstituicaoParams struct {
	Dificuldade pgtype.Text `json:"dificuldade"`
	Instituicao pgtype.Text `json:"instituicao"`
}

func (q *Queries) CountQuestionsByDificuldadeAndInstituicao(ctx context.Context, arg CountQuestionsByDificuldadeAndInstituicaoParams) (int64, error) {
	row := q.db.QueryRow(ctx, countQuestionsByDificuldadeAndInstituicao, arg.Dificuldade, arg.Instituicao)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countQuestionsByFilters = `-- name: CountQuestionsByFilters :one
SELECT COUNT(*)
FROM questions
WHERE
    ($1::TEXT IS NULL OR instituicao = $1)
    AND ($2::INT IS NULL OR ano = $2)
    AND ($3::TEXT IS NULL OR nivel = $3)
    AND ($4::TEXT IS NULL OR dificuldade = $4)
    AND ($5::TEXT IS NULL OR modalidade = $5)
    AND ($6::TEXT IS NULL OR area_atuacao = $6)
    AND ($7::TEXT IS NULL OR area_formacao = $7)
    AND ($8::UUID IS NULL OR assunto_id = $8)
    AND ($9::TEXT IS NULL OR cargo = $9)
`

type CountQuestionsByFiltersParams struct {
	Instituicao  pgtype.Text `json:"instituicao"`
	Ano          pgtype.Int4 `json:"ano"`
	Nivel        pgtype.Text `json:"nivel"`
	Dificuldade  pgtype.Text `json:"dificuldade"`
	Modalidade   pgtype.Text `json:"modalidade"`
	AreaAtuacao  pgtype.Text `json:"area_atuacao"`
	AreaFormacao pgtype.Text `json:"area_formacao"`
	AssuntoID    pgtype.UUID `json:"assunto_id"`
	Cargo        pgtype.Text `json:"cargo"`
}

func (q *Queries) CountQuestionsByFilters(ctx context.Context, arg CountQuestionsByFiltersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countQuestionsByFilters,
		arg.Instituicao,
		arg.Ano,
		arg.Nivel,
		arg.Dificuldade,
		arg.Modalidade,
		arg.AreaAtuacao,
		arg.AreaFormacao,
		arg.AssuntoID,
		arg.Cargo,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countQuestionsByInstituicao = `-- name: CountQuestionsByInstituicao :one
SELECT COUNT(*) FROM questions WHERE instituicao = $1
`

func (q *Queries) CountQuestionsByInstituicao(ctx context.Context, instituicao pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, countQuestionsByInstituicao, instituicao)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countQuestionsByInstituicaoAndCargo = `-- name: CountQuestionsByInstituicaoAndCargo :one
SELECT COUNT(*) FROM questions WHERE instituicao = $1 AND cargo = $2
`

type CountQuestionsByInstituicaoAndCargoParams struct {
	Instituicao pgtype.Text `json:"instituicao"`
	Cargo       pgtype.Text `json:"cargo"`
}

func (q *Queries) CountQuestionsByInstituicaoAndCargo(ctx context.Context, arg CountQuestionsByInstituicaoAndCargoParams) (int64, error) {
	row := q.db.QueryRow(ctx, countQuestionsByInstituicaoAndCargo, arg.Instituicao, arg.Cargo)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countQuestionsByModalidade = `-- name: CountQuestionsByModalidade :one
SELECT COUNT(*) FROM questions WHERE modalidade = $1
`

func (q *Queries) CountQuestionsByModalidade(ctx context.Context, modalidade pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, countQuestionsByModalidade, modalidade)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countQuestionsByNivel = `-- name: CountQuestionsByNivel :one
SELECT COUNT(*) FROM questions WHERE nivel = $1
`

func (q *Queries) CountQuestionsByNivel(ctx context.Context, nivel pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, countQuestionsByNivel, nivel)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createQuestion = `-- name: CreateQuestion :one
INSERT INTO
    questions (
        enunciado,
        ano,
        assunto_id,
        instituicao,
        cargo,
        nivel,
        dificuldade,
        modalidade,
        area_atuacao,
        area_formacao
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10
    ) RETURNING id, enunciado, ano, assunto_id, instituicao, cargo, nivel, dificuldade, modalidade, area_atuacao, area_formacao, created_at
`

type CreateQuestionParams struct {
	Enunciado    string      `json:"enunciado"`
	Ano          int32       `json:"ano"`
	AssuntoID    pgtype.UUID `json:"assunto_id"`
	Instituicao  pgtype.Text `json:"instituicao"`
	Cargo        pgtype.Text `json:"cargo"`
	Nivel        pgtype.Text `json:"nivel"`
	Dificuldade  pgtype.Text `json:"dificuldade"`
	Modalidade   pgtype.Text `json:"modalidade"`
	AreaAtuacao  pgtype.Text `json:"area_atuacao"`
	AreaFormacao pgtype.Text `json:"area_formacao"`
}

func (q *Queries) CreateQuestion(ctx context.Context, arg CreateQuestionParams) (Question, error) {
	row := q.db.QueryRow(ctx, createQuestion,
		arg.Enunciado,
		arg.Ano,
		arg.AssuntoID,
		arg.Instituicao,
		arg.Cargo,
		arg.Nivel,
		arg.Dificuldade,
		arg.Modalidade,
		arg.AreaAtuacao,
		arg.AreaFormacao,
	)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.Enunciado,
		&i.Ano,
		&i.AssuntoID,
		&i.Instituicao,
		&i.Cargo,
		&i.Nivel,
		&i.Dificuldade,
		&i.Modalidade,
		&i.AreaAtuacao,
		&i.AreaFormacao,
		&i.CreatedAt,
	)
	return i, err
}

const deleteQuestion = `-- name: DeleteQuestion :exec
DELETE FROM questions WHERE id = $1
`

func (q *Queries) DeleteQuestion(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteQuestion, id)
	return err
}

const getQuestion = `-- name: GetQuestion :one
SELECT id, enunciado, ano, assunto_id, instituicao, cargo, nivel, dificuldade, modalidade, area_atuacao, area_formacao, created_at FROM questions WHERE id = $1
`

func (q *Queries) GetQuestion(ctx context.Context, id pgtype.UUID) (Question, error) {
	row := q.db.QueryRow(ctx, getQuestion, id)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.Enunciado,
		&i.Ano,
		&i.AssuntoID,
		&i.Instituicao,
		&i.Cargo,
		&i.Nivel,
		&i.Dificuldade,
		&i.Modalidade,
		&i.AreaAtuacao,
		&i.AreaFormacao,
		&i.CreatedAt,
	)
	return i, err
}

const listQuestions = `-- name: ListQuestions :many
SELECT id, enunciado, ano, assunto_id, instituicao, cargo, nivel, dificuldade, modalidade, area_atuacao, area_formacao, created_at FROM questions ORDER BY created_at DESC
`

func (q *Queries) ListQuestions(ctx context.Context) ([]Question, error) {
	rows, err := q.db.Query(ctx, listQuestions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.Enunciado,
			&i.Ano,
			&i.AssuntoID,
			&i.Instituicao,
			&i.Cargo,
			&i.Nivel,
			&i.Dificuldade,
			&i.Modalidade,
			&i.AreaAtuacao,
			&i.AreaFormacao,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestionsByAno = `-- name: ListQuestionsByAno :many
SELECT id, enunciado, ano, assunto_id, instituicao, cargo, nivel, dificuldade, modalidade, area_atuacao, area_formacao, created_at FROM questions WHERE ano = $1 ORDER BY created_at DESC
`

func (q *Queries) ListQuestionsByAno(ctx context.Context, ano int32) ([]Question, error) {
	rows, err := q.db.Query(ctx, listQuestionsByAno, ano)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.Enunciado,
			&i.Ano,
			&i.AssuntoID,
			&i.Instituicao,
			&i.Cargo,
			&i.Nivel,
			&i.Dificuldade,
			&i.Modalidade,
			&i.AreaAtuacao,
			&i.AreaFormacao,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestionsByAnoAndNivel = `-- name: ListQuestionsByAnoAndNivel :many
SELECT id, enunciado, ano, assunto_id, instituicao, cargo, nivel, dificuldade, modalidade, area_atuacao, area_formacao, created_at
FROM questions
WHERE
    ano = $1
    AND nivel = $2
ORDER BY created_at DESC
`

type ListQuestionsByAnoAndNivelParams struct {
	Ano   int32       `json:"ano"`
	Nivel pgtype.Text `json:"nivel"`
}

func (q *Queries) ListQuestionsByAnoAndNivel(ctx context.Context, arg ListQuestionsByAnoAndNivelParams) ([]Question, error) {
	rows, err := q.db.Query(ctx, listQuestionsByAnoAndNivel, arg.Ano, arg.Nivel)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.Enunciado,
			&i.Ano,
			&i.AssuntoID,
			&i.Instituicao,
			&i.Cargo,
			&i.Nivel,
			&i.Dificuldade,
			&i.Modalidade,
			&i.AreaAtuacao,
			&i.AreaFormacao,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestionsByAreaAtuacao = `-- name: ListQuestionsByAreaAtuacao :many
SELECT id, enunciado, ano, assunto_id, instituicao, cargo, nivel, dificuldade, modalidade, area_atuacao, area_formacao, created_at
FROM questions
WHERE
    area_atuacao = $1
ORDER BY created_at DESC
`

func (q *Queries) ListQuestionsByAreaAtuacao(ctx context.Context, areaAtuacao pgtype.Text) ([]Question, error) {
	rows, err := q.db.Query(ctx, listQuestionsByAreaAtuacao, areaAtuacao)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.Enunciado,
			&i.Ano,
			&i.AssuntoID,
			&i.Instituicao,
			&i.Cargo,
			&i.Nivel,
			&i.Dificuldade,
			&i.Modalidade,
			&i.AreaAtuacao,
			&i.AreaFormacao,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestionsByAreaFormacao = `-- name: ListQuestionsByAreaFormacao :many
SELECT id, enunciado, ano, assunto_id, instituicao, cargo, nivel, dificuldade, modalidade, area_atuacao, area_formacao, created_at
FROM questions
WHERE
    area_formacao = $1
ORDER BY created_at DESC
`

func (q *Queries) ListQuestionsByAreaFormacao(ctx context.Context, areaFormacao pgtype.Text) ([]Question, error) {
	rows, err := q.db.Query(ctx, listQuestionsByAreaFormacao, areaFormacao)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.Enunciado,
			&i.Ano,
			&i.AssuntoID,
			&i.Instituicao,
			&i.Cargo,
			&i.Nivel,
			&i.Dificuldade,
			&i.Modalidade,
			&i.AreaAtuacao,
			&i.AreaFormacao,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestionsByAssunto = `-- name: ListQuestionsByAssunto :many
SELECT id, enunciado, ano, assunto_id, instituicao, cargo, nivel, dificuldade, modalidade, area_atuacao, area_formacao, created_at
FROM questions
WHERE
    assunto_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListQuestionsByAssunto(ctx context.Context, assuntoID pgtype.UUID) ([]Question, error) {
	rows, err := q.db.Query(ctx, listQuestionsByAssunto, assuntoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.Enunciado,
			&i.Ano,
			&i.AssuntoID,
			&i.Instituicao,
			&i.Cargo,
			&i.Nivel,
			&i.Dificuldade,
			&i.Modalidade,
			&i.AreaAtuacao,
			&i.AreaFormacao,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestionsByDificuldadeAndInstituicao = `-- name: ListQuestionsByDificuldadeAndInstituicao :many
SELECT id, enunciado, ano, assunto_id, instituicao, cargo, nivel, dificuldade, modalidade, area_atuacao, area_formacao, created_at
FROM questions
WHERE
    dificuldade = $1
    AND instituicao = $2
ORDER BY created_at DESC
`

type ListQuestionsByDificuldadeAndInstituicaoParams struct {
	Dificuldade pgtype.Text `json:"dificuldade"`
	Instituicao pgtype.Text `json:"instituicao"`
}

func (q *Queries) ListQuestionsByDificuldadeAndInstituicao(ctx context.Context, arg ListQuestionsByDificuldadeAndInstituicaoParams) ([]Question, error) {
	rows, err := q.db.Query(ctx, listQuestionsByDificuldadeAndInstituicao, arg.Dificuldade, arg.Instituicao)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.Enunciado,
			&i.Ano,
			&i.AssuntoID,
			&i.Instituicao,
			&i.Cargo,
			&i.Nivel,
			&i.Dificuldade,
			&i.Modalidade,
			&i.AreaAtuacao,
			&i.AreaFormacao,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestionsByFilters = `-- name: ListQuestionsByFilters :many
SELECT id, enunciado, ano, assunto_id, instituicao, cargo, nivel, dificuldade, modalidade, area_atuacao, area_formacao, created_at
FROM questions
WHERE
    ($1::TEXT IS NULL OR instituicao = $1)
    AND ($2::INT IS NULL OR ano = $2)
    AND ($3::TEXT IS NULL OR nivel = $3)
    AND ($4::TEXT IS NULL OR dificuldade = $4)
    AND ($5::TEXT IS NULL OR modalidade = $5)
    AND ($6::TEXT IS NULL OR area_atuacao = $6)
    AND ($7::TEXT IS NULL OR area_formacao = $7)
    AND ($8::UUID IS NULL OR assunto_id = $8)
    AND ($9::TEXT IS NULL OR cargo = $9)
ORDER BY created_at DESC
`

type ListQuestionsByFiltersParams struct {
	Instituicao  pgtype.Text `json:"instituicao"`
	Ano          pgtype.Int4 `json:"ano"`
	Nivel        pgtype.Text `json:"nivel"`
	Dificuldade  pgtype.Text `json:"dificuldade"`
	Modalidade   pgtype.Text `json:"modalidade"`
	AreaAtuacao  pgtype.Text `json:"area_atuacao"`
	AreaFormacao pgtype.Text `json:"area_formacao"`
	AssuntoID    pgtype.UUID `json:"assunto_id"`
	Cargo        pgtype.Text `json:"cargo"`
}

func (q *Queries) ListQuestionsByFilters(ctx context.Context, arg ListQuestionsByFiltersParams) ([]Question, error) {
	rows, err := q.db.Query(ctx, listQuestionsByFilters,
		arg.Instituicao,
		arg.Ano,
		arg.Nivel,
		arg.Dificuldade,
		arg.Modalidade,
		arg.AreaAtuacao,
		arg.AreaFormacao,
		arg.AssuntoID,
		arg.Cargo,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.Enunciado,
			&i.Ano,
			&i.AssuntoID,
			&i.Instituicao,
			&i.Cargo,
			&i.Nivel,
			&i.Dificuldade,
			&i.Modalidade,
			&i.AreaAtuacao,
			&i.AreaFormacao,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestionsByInstituicao = `-- name: ListQuestionsByInstituicao :many
SELECT id, enunciado, ano, assunto_id, instituicao, cargo, nivel, dificuldade, modalidade, area_atuacao, area_formacao, created_at
FROM questions
WHERE
    instituicao = $1
ORDER BY created_at DESC
`

func (q *Queries) ListQuestionsByInstituicao(ctx context.Context, instituicao pgtype.Text) ([]Question, error) {
	rows, err := q.db.Query(ctx, listQuestionsByInstituicao, instituicao)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.Enunciado,
			&i.Ano,
			&i.AssuntoID,
			&i.Instituicao,
			&i.Cargo,
			&i.Nivel,
			&i.Dificuldade,
			&i.Modalidade,
			&i.AreaAtuacao,
			&i.AreaFormacao,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestionsByInstituicaoAndCargo = `-- name: ListQuestionsByInstituicaoAndCargo :many
SELECT id, enunciado, ano, assunto_id, instituicao, cargo, nivel, dificuldade, modalidade, area_atuacao, area_formacao, created_at
FROM questions
WHERE
    instituicao = $1
    AND cargo = $2
ORDER BY created_at DESC
`

type ListQuestionsByInstituicaoAndCargoParams struct {
	Instituicao pgtype.Text `json:"instituicao"`
	Cargo       pgtype.Text `json:"cargo"`
}

func (q *Queries) ListQuestionsByInstituicaoAndCargo(ctx context.Context, arg ListQuestionsByInstituicaoAndCargoParams) ([]Question, error) {
	rows, err := q.db.Query(ctx, listQuestionsByInstituicaoAndCargo, arg.Instituicao, arg.Cargo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.Enunciado,
			&i.Ano,
			&i.AssuntoID,
			&i.Instituicao,
			&i.Cargo,
			&i.Nivel,
			&i.Dificuldade,
			&i.Modalidade,
			&i.AreaAtuacao,
			&i.AreaFormacao,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestionsByModalidade = `-- name: ListQuestionsByModalidade :many
SELECT id, enunciado, ano, assunto_id, instituicao, cargo, nivel, dificuldade, modalidade, area_atuacao, area_formacao, created_at
FROM questions
WHERE
    modalidade = $1
ORDER BY created_at DESC
`

func (q *Queries) ListQuestionsByModalidade(ctx context.Context, modalidade pgtype.Text) ([]Question, error) {
	rows, err := q.db.Query(ctx, listQuestionsByModalidade, modalidade)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.Enunciado,
			&i.Ano,
			&i.AssuntoID,
			&i.Instituicao,
			&i.Cargo,
			&i.Nivel,
			&i.Dificuldade,
			&i.Modalidade,
			&i.AreaAtuacao,
			&i.AreaFormacao,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestionsByNivel = `-- name: ListQuestionsByNivel :many
SELECT id, enunciado, ano, assunto_id, instituicao, cargo, nivel, dificuldade, modalidade, area_atuacao, area_formacao, created_at
FROM questions
WHERE
    nivel = $1
ORDER BY created_at DESC
`

func (q *Queries) ListQuestionsByNivel(ctx context.Context, nivel pgtype.Text) ([]Question, error) {
	rows, err := q.db.Query(ctx, listQuestionsByNivel, nivel)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.Enunciado,
			&i.Ano,
			&i.AssuntoID,
			&i.Instituicao,
			&i.Cargo,
			&i.Nivel,
			&i.Dificuldade,
			&i.Modalidade,
			&i.AreaAtuacao,
			&i.AreaFormacao,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateQuestion = `-- name: UpdateQuestion :one
UPDATE questions
SET
    enunciado = $2,
    ano = $3,
    assunto_id = $4,
    instituicao = $5,
    cargo = $6,
    nivel = $7,
    dificuldade = $8,
    modalidade = $9,
    area_atuacao = $10,
    area_formacao = $11
WHERE
    id = $1 RETURNING id, enunciado, ano, assunto_id, instituicao, cargo, nivel, dificuldade, modalidade, area_atuacao, area_formacao, created_at
`

type UpdateQuestionParams struct {
	ID           pgtype.UUID `json:"id"`
	Enunciado    string      `json:"enunciado"`
	Ano          int32       `json:"ano"`
	AssuntoID    pgtype.UUID `json:"assunto_id"`
	Instituicao  pgtype.Text `json:"instituicao"`
	Cargo        pgtype.Text `json:"cargo"`
	Nivel        pgtype.Text `json:"nivel"`
	Dificuldade  pgtype.Text `json:"dificuldade"`
	Modalidade   pgtype.Text `json:"modalidade"`
	AreaAtuacao  pgtype.Text `json:"area_atuacao"`
	AreaFormacao pgtype.Text `json:"area_formacao"`
}

func (q *Queries) UpdateQuestion(ctx context.Context, arg UpdateQuestionParams) (Question, error) {
	row := q.db.QueryRow(ctx, updateQuestion,
		arg.ID,
		arg.Enunciado,
		arg.Ano,
		arg.AssuntoID,
		arg.Instituicao,
		arg.Cargo,
		arg.Nivel,
		arg.Dificuldade,
		arg.Modalidade,
		arg.AreaAtuacao,
		arg.AreaFormacao,
	)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.Enunciado,
		&i.Ano,
		&i.AssuntoID,
		&i.Instituicao,
		&i.Cargo,
		&i.Nivel,
		&i.Dificuldade,
		&i.Modalidade,
		&i.AreaAtuacao,
		&i.AreaFormacao,
		&i.CreatedAt,
	)
	return i, err
}
