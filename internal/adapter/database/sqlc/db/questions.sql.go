// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: questions.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countQuestions = `-- name: CountQuestions :one
SELECT COUNT(*) FROM questions
`

func (q *Queries) CountQuestions(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countQuestions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countQuestionsByFieldOfStudy = `-- name: CountQuestionsByFieldOfStudy :one
SELECT COUNT(*) FROM questions WHERE field_of_study = $1
`

func (q *Queries) CountQuestionsByFieldOfStudy(ctx context.Context, fieldOfStudy pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, countQuestionsByFieldOfStudy, fieldOfStudy)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countQuestionsByFilters = `-- name: CountQuestionsByFilters :one
SELECT COUNT(*)
FROM questions
WHERE
    ($1::INT IS NULL OR year = $1)
    AND ($2::TEXT IS NULL OR level = $2)
    AND ($3::TEXT IS NULL OR difficulty = $3)
    AND ($4::TEXT IS NULL OR modality = $4)
    AND ($5::TEXT IS NULL OR practice_area = $5)
    AND ($6::TEXT IS NULL OR field_of_study = $6)
    AND ($7::UUID IS NULL OR topic_id = $7)
    AND ($8::TEXT IS NULL OR position = $8)
`

type CountQuestionsByFiltersParams struct {
	Year         pgtype.Int4 `json:"year"`
	Level        pgtype.Text `json:"level"`
	Difficulty   pgtype.Text `json:"difficulty"`
	Modality     pgtype.Text `json:"modality"`
	PracticeArea pgtype.Text `json:"practice_area"`
	FieldOfStudy pgtype.Text `json:"field_of_study"`
	TopicID      pgtype.UUID `json:"topic_id"`
	Position     pgtype.Text `json:"position"`
}

func (q *Queries) CountQuestionsByFilters(ctx context.Context, arg CountQuestionsByFiltersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countQuestionsByFilters,
		arg.Year,
		arg.Level,
		arg.Difficulty,
		arg.Modality,
		arg.PracticeArea,
		arg.FieldOfStudy,
		arg.TopicID,
		arg.Position,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countQuestionsByLevel = `-- name: CountQuestionsByLevel :one
SELECT COUNT(*) FROM questions WHERE level = $1
`

func (q *Queries) CountQuestionsByLevel(ctx context.Context, level pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, countQuestionsByLevel, level)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countQuestionsByModality = `-- name: CountQuestionsByModality :one
SELECT COUNT(*) FROM questions WHERE modality = $1
`

func (q *Queries) CountQuestionsByModality(ctx context.Context, modality pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, countQuestionsByModality, modality)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countQuestionsByPracticeArea = `-- name: CountQuestionsByPracticeArea :one
SELECT COUNT(*) FROM questions WHERE practice_area = $1
`

func (q *Queries) CountQuestionsByPracticeArea(ctx context.Context, practiceArea pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, countQuestionsByPracticeArea, practiceArea)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countQuestionsByTopic = `-- name: CountQuestionsByTopic :one
SELECT COUNT(*) FROM questions WHERE topic_id = $1
`

func (q *Queries) CountQuestionsByTopic(ctx context.Context, topicID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countQuestionsByTopic, topicID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countQuestionsByYear = `-- name: CountQuestionsByYear :one
SELECT COUNT(*) FROM questions WHERE year = $1
`

func (q *Queries) CountQuestionsByYear(ctx context.Context, year int32) (int64, error) {
	row := q.db.QueryRow(ctx, countQuestionsByYear, year)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countQuestionsByYearAndLevel = `-- name: CountQuestionsByYearAndLevel :one
SELECT COUNT(*) FROM questions WHERE year = $1 AND level = $2
`

type CountQuestionsByYearAndLevelParams struct {
	Year  int32       `json:"year"`
	Level pgtype.Text `json:"level"`
}

func (q *Queries) CountQuestionsByYearAndLevel(ctx context.Context, arg CountQuestionsByYearAndLevelParams) (int64, error) {
	row := q.db.QueryRow(ctx, countQuestionsByYearAndLevel, arg.Year, arg.Level)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countQuestionsForExam = `-- name: CountQuestionsForExam :one
SELECT COUNT(*)
FROM questions q
JOIN topics t ON q.topic_id = t.id
JOIN subjects s ON t.subject_id = s.id
WHERE 
    s.id = $1 
    AND ($2::uuid IS NULL OR q.topic_id = $2)
    AND ($3::text IS NULL OR q.position = $3)
    AND ($4::text IS NULL OR q.level = $4)
    AND ($5::text IS NULL OR q.difficulty = $5)
    AND ($6::text IS NULL OR q.modality = $6)
    AND ($7::text IS NULL OR q.field_of_study = $7)
    AND ($8::int IS NULL OR q.year >= $8)
    AND ($9::int IS NULL OR q.year <= $9)
`

type CountQuestionsForExamParams struct {
	ID           pgtype.UUID `json:"id"`
	TopicID      pgtype.UUID `json:"topic_id"`
	Position     pgtype.Text `json:"position"`
	Level        pgtype.Text `json:"level"`
	Difficulty   pgtype.Text `json:"difficulty"`
	Modality     pgtype.Text `json:"modality"`
	FieldOfStudy pgtype.Text `json:"field_of_study"`
	MinYear      pgtype.Int4 `json:"min_year"`
	MaxYear      pgtype.Int4 `json:"max_year"`
}

func (q *Queries) CountQuestionsForExam(ctx context.Context, arg CountQuestionsForExamParams) (int64, error) {
	row := q.db.QueryRow(ctx, countQuestionsForExam,
		arg.ID,
		arg.TopicID,
		arg.Position,
		arg.Level,
		arg.Difficulty,
		arg.Modality,
		arg.FieldOfStudy,
		arg.MinYear,
		arg.MaxYear,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createQuestion = `-- name: CreateQuestion :one
INSERT INTO
    questions (
        statement,
        year,
        topic_id,
        position,
        level,
        difficulty,
        modality,
        practice_area,
        field_of_study
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9
    ) RETURNING id, statement, year, topic_id, position, level, difficulty, modality, practice_area, field_of_study, created_at
`

type CreateQuestionParams struct {
	Statement    string      `json:"statement"`
	Year         int32       `json:"year"`
	TopicID      pgtype.UUID `json:"topic_id"`
	Position     pgtype.Text `json:"position"`
	Level        pgtype.Text `json:"level"`
	Difficulty   pgtype.Text `json:"difficulty"`
	Modality     pgtype.Text `json:"modality"`
	PracticeArea pgtype.Text `json:"practice_area"`
	FieldOfStudy pgtype.Text `json:"field_of_study"`
}

func (q *Queries) CreateQuestion(ctx context.Context, arg CreateQuestionParams) (Question, error) {
	row := q.db.QueryRow(ctx, createQuestion,
		arg.Statement,
		arg.Year,
		arg.TopicID,
		arg.Position,
		arg.Level,
		arg.Difficulty,
		arg.Modality,
		arg.PracticeArea,
		arg.FieldOfStudy,
	)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.Statement,
		&i.Year,
		&i.TopicID,
		&i.Position,
		&i.Level,
		&i.Difficulty,
		&i.Modality,
		&i.PracticeArea,
		&i.FieldOfStudy,
		&i.CreatedAt,
	)
	return i, err
}

const deleteQuestion = `-- name: DeleteQuestion :exec
DELETE FROM questions WHERE id = $1
`

func (q *Queries) DeleteQuestion(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteQuestion, id)
	return err
}

const getQuestion = `-- name: GetQuestion :one
SELECT id, statement, year, topic_id, position, level, difficulty, modality, practice_area, field_of_study, created_at FROM questions WHERE id = $1
`

func (q *Queries) GetQuestion(ctx context.Context, id pgtype.UUID) (Question, error) {
	row := q.db.QueryRow(ctx, getQuestion, id)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.Statement,
		&i.Year,
		&i.TopicID,
		&i.Position,
		&i.Level,
		&i.Difficulty,
		&i.Modality,
		&i.PracticeArea,
		&i.FieldOfStudy,
		&i.CreatedAt,
	)
	return i, err
}

const getQuestionsForExam = `-- name: GetQuestionsForExam :many
SELECT 
    q.id, q.statement, q.year, q.position, q.level,
    q.difficulty, q.modality, q.field_of_study,
    t.name as topic_name, s.name as subject_name
FROM questions q
JOIN topics t ON q.topic_id = t.id
JOIN subjects s ON t.subject_id = s.id
WHERE 
    s.id = $1 
    AND ($3::uuid IS NULL OR q.topic_id = $3)
    AND ($4::text IS NULL OR q.position = $4)
    AND ($5::text IS NULL OR q.level = $5)
    AND ($6::text IS NULL OR q.difficulty = $6)
    AND ($7::text IS NULL OR q.modality = $7)
    AND ($8::text IS NULL OR q.field_of_study = $8)
    AND ($9::int IS NULL OR q.year >= $9)
    AND ($10::int IS NULL OR q.year <= $10)
ORDER BY RANDOM()
LIMIT $2
`

type GetQuestionsForExamParams struct {
	ID           pgtype.UUID `json:"id"`
	Limit        int32       `json:"limit"`
	TopicID      pgtype.UUID `json:"topic_id"`
	Position     pgtype.Text `json:"position"`
	Level        pgtype.Text `json:"level"`
	Difficulty   pgtype.Text `json:"difficulty"`
	Modality     pgtype.Text `json:"modality"`
	FieldOfStudy pgtype.Text `json:"field_of_study"`
	MinYear      pgtype.Int4 `json:"min_year"`
	MaxYear      pgtype.Int4 `json:"max_year"`
}

type GetQuestionsForExamRow struct {
	ID           pgtype.UUID `json:"id"`
	Statement    string      `json:"statement"`
	Year         int32       `json:"year"`
	Position     pgtype.Text `json:"position"`
	Level        pgtype.Text `json:"level"`
	Difficulty   pgtype.Text `json:"difficulty"`
	Modality     pgtype.Text `json:"modality"`
	FieldOfStudy pgtype.Text `json:"field_of_study"`
	TopicName    string      `json:"topic_name"`
	SubjectName  string      `json:"subject_name"`
}

func (q *Queries) GetQuestionsForExam(ctx context.Context, arg GetQuestionsForExamParams) ([]GetQuestionsForExamRow, error) {
	rows, err := q.db.Query(ctx, getQuestionsForExam,
		arg.ID,
		arg.Limit,
		arg.TopicID,
		arg.Position,
		arg.Level,
		arg.Difficulty,
		arg.Modality,
		arg.FieldOfStudy,
		arg.MinYear,
		arg.MaxYear,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetQuestionsForExamRow{}
	for rows.Next() {
		var i GetQuestionsForExamRow
		if err := rows.Scan(
			&i.ID,
			&i.Statement,
			&i.Year,
			&i.Position,
			&i.Level,
			&i.Difficulty,
			&i.Modality,
			&i.FieldOfStudy,
			&i.TopicName,
			&i.SubjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestions = `-- name: ListQuestions :many
SELECT id, statement, year, topic_id, position, level, difficulty, modality, practice_area, field_of_study, created_at FROM questions ORDER BY created_at DESC
`

func (q *Queries) ListQuestions(ctx context.Context) ([]Question, error) {
	rows, err := q.db.Query(ctx, listQuestions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.Statement,
			&i.Year,
			&i.TopicID,
			&i.Position,
			&i.Level,
			&i.Difficulty,
			&i.Modality,
			&i.PracticeArea,
			&i.FieldOfStudy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestionsByFieldOfStudy = `-- name: ListQuestionsByFieldOfStudy :many
SELECT id, statement, year, topic_id, position, level, difficulty, modality, practice_area, field_of_study, created_at
FROM questions
WHERE
    field_of_study = $1
ORDER BY created_at DESC
`

func (q *Queries) ListQuestionsByFieldOfStudy(ctx context.Context, fieldOfStudy pgtype.Text) ([]Question, error) {
	rows, err := q.db.Query(ctx, listQuestionsByFieldOfStudy, fieldOfStudy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.Statement,
			&i.Year,
			&i.TopicID,
			&i.Position,
			&i.Level,
			&i.Difficulty,
			&i.Modality,
			&i.PracticeArea,
			&i.FieldOfStudy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestionsByFilters = `-- name: ListQuestionsByFilters :many
SELECT id, statement, year, topic_id, position, level, difficulty, modality, practice_area, field_of_study, created_at
FROM questions
WHERE
    ($1::INT IS NULL OR year = $1)
    AND ($2::TEXT IS NULL OR level = $2)
    AND ($3::TEXT IS NULL OR difficulty = $3)
    AND ($4::TEXT IS NULL OR modality = $4)
    AND ($5::TEXT IS NULL OR practice_area = $5)
    AND ($6::TEXT IS NULL OR field_of_study = $6)
    AND ($7::UUID IS NULL OR topic_id = $7)
    AND ($8::TEXT IS NULL OR position = $8)
    AND ($9::INT IS NULL OR TRUE)
ORDER BY created_at DESC
`

type ListQuestionsByFiltersParams struct {
	Year           pgtype.Int4 `json:"year"`
	Level          pgtype.Text `json:"level"`
	Difficulty     pgtype.Text `json:"difficulty"`
	Modality       pgtype.Text `json:"modality"`
	PracticeArea   pgtype.Text `json:"practice_area"`
	FieldOfStudy   pgtype.Text `json:"field_of_study"`
	TopicID        pgtype.UUID `json:"topic_id"`
	Position       pgtype.Text `json:"position"`
	QuestionsCount pgtype.Int4 `json:"questions_count"`
}

func (q *Queries) ListQuestionsByFilters(ctx context.Context, arg ListQuestionsByFiltersParams) ([]Question, error) {
	rows, err := q.db.Query(ctx, listQuestionsByFilters,
		arg.Year,
		arg.Level,
		arg.Difficulty,
		arg.Modality,
		arg.PracticeArea,
		arg.FieldOfStudy,
		arg.TopicID,
		arg.Position,
		arg.QuestionsCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.Statement,
			&i.Year,
			&i.TopicID,
			&i.Position,
			&i.Level,
			&i.Difficulty,
			&i.Modality,
			&i.PracticeArea,
			&i.FieldOfStudy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestionsByFiltersWithChoices = `-- name: ListQuestionsByFiltersWithChoices :many
SELECT 
    q.id, q.statement, q.year, q.position, q.level,
    q.difficulty, q.modality, q.practice_area, q.field_of_study,
    c.id as choice_id, c.choice_text, c.is_correct
FROM questions q
LEFT JOIN choices c ON q.id = c.question_id
WHERE
    ($1::INT IS NULL OR q.year = $1)
    AND ($2::TEXT IS NULL OR q.level = $2)
    AND ($3::TEXT IS NULL OR q.difficulty = $3)
    AND ($4::TEXT IS NULL OR q.modality = $4)
    AND ($5::TEXT IS NULL OR q.practice_area = $5)
    AND ($6::TEXT IS NULL OR q.field_of_study = $6)
    AND ($7::UUID IS NULL OR q.topic_id = $7)
    AND ($8::TEXT IS NULL OR q.position = $8)
ORDER BY q.created_at DESC
`

type ListQuestionsByFiltersWithChoicesParams struct {
	Year         pgtype.Int4 `json:"year"`
	Level        pgtype.Text `json:"level"`
	Difficulty   pgtype.Text `json:"difficulty"`
	Modality     pgtype.Text `json:"modality"`
	PracticeArea pgtype.Text `json:"practice_area"`
	FieldOfStudy pgtype.Text `json:"field_of_study"`
	TopicID      pgtype.UUID `json:"topic_id"`
	Position     pgtype.Text `json:"position"`
}

type ListQuestionsByFiltersWithChoicesRow struct {
	ID           pgtype.UUID `json:"id"`
	Statement    string      `json:"statement"`
	Year         int32       `json:"year"`
	Position     pgtype.Text `json:"position"`
	Level        pgtype.Text `json:"level"`
	Difficulty   pgtype.Text `json:"difficulty"`
	Modality     pgtype.Text `json:"modality"`
	PracticeArea pgtype.Text `json:"practice_area"`
	FieldOfStudy pgtype.Text `json:"field_of_study"`
	ChoiceID     pgtype.UUID `json:"choice_id"`
	ChoiceText   pgtype.Text `json:"choice_text"`
	IsCorrect    pgtype.Bool `json:"is_correct"`
}

func (q *Queries) ListQuestionsByFiltersWithChoices(ctx context.Context, arg ListQuestionsByFiltersWithChoicesParams) ([]ListQuestionsByFiltersWithChoicesRow, error) {
	rows, err := q.db.Query(ctx, listQuestionsByFiltersWithChoices,
		arg.Year,
		arg.Level,
		arg.Difficulty,
		arg.Modality,
		arg.PracticeArea,
		arg.FieldOfStudy,
		arg.TopicID,
		arg.Position,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListQuestionsByFiltersWithChoicesRow{}
	for rows.Next() {
		var i ListQuestionsByFiltersWithChoicesRow
		if err := rows.Scan(
			&i.ID,
			&i.Statement,
			&i.Year,
			&i.Position,
			&i.Level,
			&i.Difficulty,
			&i.Modality,
			&i.PracticeArea,
			&i.FieldOfStudy,
			&i.ChoiceID,
			&i.ChoiceText,
			&i.IsCorrect,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestionsByLevel = `-- name: ListQuestionsByLevel :many
SELECT id, statement, year, topic_id, position, level, difficulty, modality, practice_area, field_of_study, created_at
FROM questions
WHERE
    level = $1
ORDER BY created_at DESC
`

func (q *Queries) ListQuestionsByLevel(ctx context.Context, level pgtype.Text) ([]Question, error) {
	rows, err := q.db.Query(ctx, listQuestionsByLevel, level)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.Statement,
			&i.Year,
			&i.TopicID,
			&i.Position,
			&i.Level,
			&i.Difficulty,
			&i.Modality,
			&i.PracticeArea,
			&i.FieldOfStudy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestionsByModality = `-- name: ListQuestionsByModality :many
SELECT id, statement, year, topic_id, position, level, difficulty, modality, practice_area, field_of_study, created_at
FROM questions
WHERE
    modality = $1
ORDER BY created_at DESC
`

func (q *Queries) ListQuestionsByModality(ctx context.Context, modality pgtype.Text) ([]Question, error) {
	rows, err := q.db.Query(ctx, listQuestionsByModality, modality)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.Statement,
			&i.Year,
			&i.TopicID,
			&i.Position,
			&i.Level,
			&i.Difficulty,
			&i.Modality,
			&i.PracticeArea,
			&i.FieldOfStudy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestionsByPracticeArea = `-- name: ListQuestionsByPracticeArea :many
SELECT id, statement, year, topic_id, position, level, difficulty, modality, practice_area, field_of_study, created_at
FROM questions
WHERE
    practice_area = $1
ORDER BY created_at DESC
`

func (q *Queries) ListQuestionsByPracticeArea(ctx context.Context, practiceArea pgtype.Text) ([]Question, error) {
	rows, err := q.db.Query(ctx, listQuestionsByPracticeArea, practiceArea)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.Statement,
			&i.Year,
			&i.TopicID,
			&i.Position,
			&i.Level,
			&i.Difficulty,
			&i.Modality,
			&i.PracticeArea,
			&i.FieldOfStudy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestionsByTopic = `-- name: ListQuestionsByTopic :many
SELECT id, statement, year, topic_id, position, level, difficulty, modality, practice_area, field_of_study, created_at
FROM questions
WHERE
    topic_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListQuestionsByTopic(ctx context.Context, topicID pgtype.UUID) ([]Question, error) {
	rows, err := q.db.Query(ctx, listQuestionsByTopic, topicID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.Statement,
			&i.Year,
			&i.TopicID,
			&i.Position,
			&i.Level,
			&i.Difficulty,
			&i.Modality,
			&i.PracticeArea,
			&i.FieldOfStudy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestionsByYear = `-- name: ListQuestionsByYear :many
SELECT id, statement, year, topic_id, position, level, difficulty, modality, practice_area, field_of_study, created_at FROM questions WHERE year = $1 ORDER BY created_at DESC
`

func (q *Queries) ListQuestionsByYear(ctx context.Context, year int32) ([]Question, error) {
	rows, err := q.db.Query(ctx, listQuestionsByYear, year)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.Statement,
			&i.Year,
			&i.TopicID,
			&i.Position,
			&i.Level,
			&i.Difficulty,
			&i.Modality,
			&i.PracticeArea,
			&i.FieldOfStudy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestionsByYearAndLevel = `-- name: ListQuestionsByYearAndLevel :many
SELECT id, statement, year, topic_id, position, level, difficulty, modality, practice_area, field_of_study, created_at
FROM questions
WHERE
    year = $1
    AND level = $2
ORDER BY created_at DESC
`

type ListQuestionsByYearAndLevelParams struct {
	Year  int32       `json:"year"`
	Level pgtype.Text `json:"level"`
}

func (q *Queries) ListQuestionsByYearAndLevel(ctx context.Context, arg ListQuestionsByYearAndLevelParams) ([]Question, error) {
	rows, err := q.db.Query(ctx, listQuestionsByYearAndLevel, arg.Year, arg.Level)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.Statement,
			&i.Year,
			&i.TopicID,
			&i.Position,
			&i.Level,
			&i.Difficulty,
			&i.Modality,
			&i.PracticeArea,
			&i.FieldOfStudy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const questionExistsByStatement = `-- name: QuestionExistsByStatement :one
SELECT EXISTS (
        SELECT 1
        FROM questions
        WHERE
            statement = $1
    ) AS exists
`

func (q *Queries) QuestionExistsByStatement(ctx context.Context, statement string) (bool, error) {
	row := q.db.QueryRow(ctx, questionExistsByStatement, statement)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateQuestion = `-- name: UpdateQuestion :one
UPDATE questions
SET
    statement = $2,
    year = $3,
    topic_id = $4,
    position = $5,
    level = $6,
    difficulty = $7,
    modality = $8,
    practice_area = $9,
    field_of_study = $10
WHERE
    id = $1 RETURNING id, statement, year, topic_id, position, level, difficulty, modality, practice_area, field_of_study, created_at
`

type UpdateQuestionParams struct {
	ID           pgtype.UUID `json:"id"`
	Statement    string      `json:"statement"`
	Year         int32       `json:"year"`
	TopicID      pgtype.UUID `json:"topic_id"`
	Position     pgtype.Text `json:"position"`
	Level        pgtype.Text `json:"level"`
	Difficulty   pgtype.Text `json:"difficulty"`
	Modality     pgtype.Text `json:"modality"`
	PracticeArea pgtype.Text `json:"practice_area"`
	FieldOfStudy pgtype.Text `json:"field_of_study"`
}

func (q *Queries) UpdateQuestion(ctx context.Context, arg UpdateQuestionParams) (Question, error) {
	row := q.db.QueryRow(ctx, updateQuestion,
		arg.ID,
		arg.Statement,
		arg.Year,
		arg.TopicID,
		arg.Position,
		arg.Level,
		arg.Difficulty,
		arg.Modality,
		arg.PracticeArea,
		arg.FieldOfStudy,
	)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.Statement,
		&i.Year,
		&i.TopicID,
		&i.Position,
		&i.Level,
		&i.Difficulty,
		&i.Modality,
		&i.PracticeArea,
		&i.FieldOfStudy,
		&i.CreatedAt,
	)
	return i, err
}
